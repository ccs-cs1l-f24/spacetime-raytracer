use crate::boilerplate::BaseGpuState;

pub mod aloofbody;
pub mod softbody;
pub mod worldline;

mod utils;

fn include_callback(
    requested_src: &str,
    _: shaderc::IncludeType,
    _: &str,
    _: usize,
) -> Result<shaderc::ResolvedInclude, String> {
    let content = std::fs::read_to_string(
        std::path::PathBuf::new()
            .join("src")
            .join("twoplusone")
            .join(requested_src),
    )
    .map_err(|e| e.to_string())?;
    Ok(shaderc::ResolvedInclude {
        content,
        resolved_name: requested_src.to_string(),
    })
}

pub struct PipelineManager {
    pub point_pipelines: softbody::point_render_nr::PointRenderPipelines,
    pub softbody_compute: softbody::SoftbodyComputePipelines,
}

pub fn create_pipeline_manager(base: &BaseGpuState) -> PipelineManager {
    PipelineManager {
        point_pipelines: softbody::point_render_nr::create_point_render_pipelines(base),
        softbody_compute: softbody::create_softbody_compute_pipelines(base),
    }
}

pub struct World {
    // debug camera
    pub cam_ground_pos: [f32; 2],
    // lightseconds per screenspace (whichever of window width/height is bigger)
    pub zoom: f32,

    // softbodies (physics-y/moving/colliding relativistic bodies --- most game objects)
    pub softbody_state: softbody::SoftbodyState,
    // aloofbodies (floating/sometimes moving relativistic bodies --- text/UI)

    // worldlines (used for relativistic rendering; fed/generated by soft/aloofbody states)
}

impl World {
    pub fn update_camera(&mut self, keyboard: &crate::keyboard::Keyboard, timestep: f32) {
        const SPEED: f32 = 0.6;
        const ZOOM_FACTOR: f32 = 1.0;
        self.cam_ground_pos[0] += keyboard.right as u8 as f32 * timestep * SPEED;
        self.cam_ground_pos[0] -= keyboard.left as u8 as f32 * timestep * SPEED;
        self.cam_ground_pos[1] += keyboard.down as u8 as f32 * timestep * SPEED;
        self.cam_ground_pos[1] -= keyboard.up as u8 as f32 * timestep * SPEED;
        self.zoom -= keyboard.z as u8 as f32 * timestep * ZOOM_FACTOR;
        self.zoom += keyboard.x as u8 as f32 * timestep * ZOOM_FACTOR;
    }
}

pub fn create_world(base: &BaseGpuState, pipelines: &PipelineManager) -> World {
    let mut softbody_state = softbody::SoftbodyState::create(base, &pipelines.softbody_compute);
    softbody_state.add_particles(
        &mut softbody::image_to_softbody(
            include_bytes!("../../softbodyimages/testimg3.png").as_slice(),
            0,
            [0.0, 0.0],
            [0.4, 0.0],
        ),
        softbody::Object {
            offset: 0,
            material_index: 0,
            _a: 0,
            _b: 0,
        },
    );
    softbody_state.add_particles(
        &mut softbody::image_to_softbody(
            include_bytes!("../../softbodyimages/testimg4.png").as_slice(),
            1,
            [2.0, 0.0],
            [0.0, 0.0],
        ),
        softbody::Object {
            offset: softbody_state.num_particles() as u32,
            material_index: 0,
            _a: 0,
            _b: 0,
        },
    );
    softbody_state.push(base);
    World {
        cam_ground_pos: [0.5, 0.5],
        zoom: 1.0,
        softbody_state,
    }
}
