use crate::boilerplate::BaseGpuState;

pub mod aloofbody;
pub mod softbody;
pub mod worldline;

mod utils;

// it's easier to keep all the constants for the everything in one place
// since many are shared across submodules
// (this is to say the collision grid is used by the worldline module)
pub mod consts {
    pub(super) const H: f32 = 0.005;
    pub(super) const K: f32 = 15000.0;
    pub(super) const IMMEDIATE_NEIGHBOR_DIST: f32 = 0.0035;
    pub(super) const DIAGONAL_NEIGHBOR_DIST: f32 = 0.00494974747;
    pub(super) const GRID_RESOLUTION: f32 = 0.005;
    pub(super) const COLLISION_DISTANCE: f32 = 0.002;
    pub(super) const COLLISION_REPULSION_COEFFICIENT: f32 = 75.0;
    pub(super) const BOND_BREAK_THRESHOLD: f32 = 0.01;
    pub(super) const RK4_PUSH_CONSTS: super::softbody::Rk4PushConstants =
        super::softbody::Rk4PushConstants {
            // to be overriden
            num_particles: 0,
            // the rest
            h: H,
            immediate_neighbor_dist: IMMEDIATE_NEIGHBOR_DIST,
            diagonal_neighbor_dist: DIAGONAL_NEIGHBOR_DIST,
            k: K,
            grid_resolution: GRID_RESOLUTION,
            collision_distance: COLLISION_DISTANCE,
            collision_repulsion_coefficient: COLLISION_REPULSION_COEFFICIENT,
            bond_break_threshold: BOND_BREAK_THRESHOLD,
        };
}

pub struct PipelineManager {
    pub point_pipelines: softbody::point_render_nr::PointRenderPipelines,
    pub softbody_compute: softbody::SoftbodyComputePipelines,

    pub worldline_update_softbodies: worldline::UpdateSoftbodiesComputePipelines,
}

// needs to take base mutably because it updates pipeline cache registry
pub fn create_pipeline_manager(base: &mut BaseGpuState) -> PipelineManager {
    PipelineManager {
        point_pipelines: softbody::point_render_nr::create_point_render_pipelines(base),
        softbody_compute: softbody::create_softbody_compute_pipelines(base),
        worldline_update_softbodies: worldline::create_update_softbodies(base),
    }
}

pub struct World {
    // debug camera
    pub cam_ground_pos: [f32; 2],
    // lightseconds per screenspace (whichever of window width/height is bigger)
    pub zoom: f32,

    // softbodies (physics-y/moving/colliding relativistic bodies --- most game objects)
    pub softbody_state: softbody::SoftbodyState,
    // aloofbodies (floating/sometimes moving relativistic bodies --- text/UI)

    // worldlines (used for relativistic rendering; fed/generated by soft/aloofbody states)
    pub worldline_update_softbodies_state: worldline::UpdateSoftbodiesState,
}

impl World {
    pub fn update_camera(&mut self, keyboard: &crate::keyboard::Keyboard, timestep: f32) {
        const SPEED: f32 = 0.6;
        const ZOOM_FACTOR: f32 = 1.0;
        self.cam_ground_pos[0] += keyboard.right as u8 as f32 * timestep * SPEED;
        self.cam_ground_pos[0] -= keyboard.left as u8 as f32 * timestep * SPEED;
        self.cam_ground_pos[1] += keyboard.down as u8 as f32 * timestep * SPEED;
        self.cam_ground_pos[1] -= keyboard.up as u8 as f32 * timestep * SPEED;
        self.zoom -= keyboard.z as u8 as f32 * timestep * ZOOM_FACTOR;
        self.zoom += keyboard.x as u8 as f32 * timestep * ZOOM_FACTOR;
    }
}

pub fn create_world(base: &BaseGpuState, pipelines: &PipelineManager) -> World {
    let mut softbody_state = softbody::SoftbodyState::create(base, &pipelines.softbody_compute);
    softbody_state.add_particles(
        &mut softbody::image_to_softbody(
            include_bytes!("../../softbodyimages/testimg4.png").as_slice(),
            0,
            [0.0, 0.0],
            [0.2, 0.2],
        ),
        softbody::Object {
            offset: 0,
            material_index: 0,
            _a: 0,
            _b: 0,
        },
    );
    softbody_state.add_particles(
        &mut softbody::image_to_softbody(
            include_bytes!("../../softbodyimages/testimg5.png").as_slice(),
            1,
            [1.2, 0.8],
            [-0.2, -0.2],
        ),
        softbody::Object {
            offset: softbody_state.num_particles() as u32,
            material_index: 0,
            _a: 0,
            _b: 0,
        },
    );
    softbody_state.push(base);
    let worldline_update_softbodies_state = worldline::UpdateSoftbodiesState::create(
        base,
        &pipelines.worldline_update_softbodies,
        &softbody_state,
    );
    World {
        cam_ground_pos: [0.5, 0.5],
        zoom: 1.0,
        softbody_state,
        worldline_update_softbodies_state,
    }
}
